import { z } from "zod";
import { listableInts, listableString } from "../../utils";
import { FwMark, ListenOptions } from "../shared";

export const HTTPProxyOptions = z.object({
  enabled: z.boolean().optional().meta({
    description: "Enable system HTTP proxy.",
    description_zh: "启用系统 HTTP 代理。",
  }),
  server: z.string().meta({
    description: "HTTP proxy server address (required).",
    description_zh: "系统 HTTP 代理服务器地址（必填）。",
  }),
  server_port: z.number().int().meta({
    description: "HTTP proxy server port (required).",
    description_zh: "系统 HTTP 代理服务器端口（必填）。",
  }),
  bypass_domain: listableString.optional().meta({
    description:
      "Hostnames that bypass the HTTP proxy. On Apple platforms, `bypass_domain` items match hostname suffixes.",
    description_zh:
      "绕过代理的主机名列表。在 Apple 平台上，`bypass_domain` 项匹配主机名后缀。",
  }),
  match_domain: listableString.optional().meta({
    description:
      "Hostnames that use the HTTP proxy. Only supported in graphical clients on Apple platforms.",
    description_zh: "代理的主机名列表。仅在 Apple 平台图形客户端中支持。",
  }),
});

export const TunPlatformOptions = z.object({
  http_proxy: HTTPProxyOptions.optional().meta({
    description: "System HTTP proxy settings.",
    description_zh: "系统 HTTP 代理设置。",
  }),
});

export const TunInboundOptions = z
  .object({
    type: z.literal("tun"),
    tag: z.string().optional(),
    interface_name: z.string().optional().meta({
      description: "Virtual device name, automatically selected if empty.",
      description_zh: "虚拟设备名称，默认自动选择。",
    }),
    address: listableString.optional().meta({
      description: "IPv4 and IPv6 prefix for the tun interface.",
      description_zh: "tun 接口的 IPv4 和 IPv6 前缀。",
    }),
    mtu: z.number().int().optional().meta({
      description: "The maximum transmission unit.",
      description_zh: "最大传输单元。",
    }),
    auto_route: z.boolean().optional().meta({
      description:
        "Set the default route to the Tun. To avoid traffic loopback, set `route.auto_detect_interface`, `route.default_interface`, or `outbound.bind_interface`. `auto_redirect` is always recommended on Linux for better routing and performance, and to avoid conflicts with Docker bridge networks. On Android VPN, enable `route.override_android_vpn` so Tun traffic goes through the VPN.",
      description_zh:
        "设置到 Tun 的默认路由。为避免流量环回，请设置 `route.auto_detect_interface` 或 `route.default_interface` 或 `outbound.bind_interface`。在 Linux 上，始终推荐启用 `auto_redirect` 以获得更好的路由和性能，并避免与 Docker 桥接网络冲突。使用 Android VPN 时，启用 `route.override_android_vpn` 以使 Tun 流量通过 VPN。",
    }),
    iproute2_table_index: z.number().int().optional().meta({
      description: "Linux iproute2 table index generated by `auto_route`.",
      description_zh: "`auto_route` 生成的 iproute2 路由表索引。",
    }),
    iproute2_rule_index: z.number().int().optional().meta({
      description: "Linux iproute2 rule start index generated by `auto_route`.",
      description_zh: "`auto_route` 生成的 iproute2 规则起始索引。",
    }),
    auto_redirect: z.boolean().optional().meta({
      description:
        "Improve TUN routing and performance using nftables. Only supported on Linux with `auto_route` enabled; on Android only simple IPv4 TCP forwarding is performed due to missing nftables and ip6tables, and sharing your VPN connection over hotspot or repeater requires VPNHotspot (https://github.com/Mygod/VPNHotspot). auto_redirect automatically inserts compatibility rules into the OpenWrt fw4 table and conflicts with `route.default_mark` and `[dialOptions].routing_mark`.",
      description_zh:
        "通过使用 nftables 改善 TUN 路由和性能。仅在 Linux 且启用了 `auto_route` 时支持；在 Android 上由于缺少 nftables 和 ip6tables，仅执行简单的 IPv4 TCP 转发，并且要通过热点或中继器共享 VPN 连接，请使用 VPNHotspot (https://github.com/Mygod/VPNHotspot)。auto_redirect 会自动将兼容规则插入 OpenWrt fw4 表，并与 `route.default_mark` 和 `[dialOptions].routing_mark` 冲突。",
    }),
    auto_redirect_input_mark: FwMark.optional().meta({
      description:
        "Connection input mark used by `auto_redirect`. `0x2023` is used by default.",
      description_zh: "`auto_redirect` 使用的连接输入标记。默认使用 `0x2023`。",
    }),
    auto_redirect_output_mark: FwMark.optional().meta({
      description:
        "Connection output mark used by `auto_redirect`. `0x2024` is used by default.",
      description_zh: "`auto_redirect` 使用的连接输出标记。默认使用 `0x2024`。",
    }),
    auto_redirect_iproute2_fallback_rule_index: z
      .number()
      .int()
      .optional()
      .meta({
        description:
          "Linux iproute2 fallback rule index generated by `auto_redirect`. This rule is checked after system default rules (32766: main, 32767: default), routing traffic to the sing-box table only when no route is found in system tables. `32768` is used by default.",
        description_zh:
          "`auto_redirect` 生成的 iproute2 回退规则索引。此规则在系统默认规则（32766: main，32767: default）之后检查，仅当系统路由表中未找到路由时才将流量路由到 sing-box 路由表。默认使用 `32768`。",
      }),
    loopback_address: listableString.optional().meta({
      description:
        "Loopback addresses make TCP connections to the specified address connect to the source address. Setting the option to `10.7.0.1` achieves the same behavior as SideStore/StosVPN, and with `auto_redirect` enabled the same behavior can be achieved for LAN devices as a gateway.",
      description_zh:
        "环回地址是用于使指向指定地址的 TCP 连接连接到来源地址的。将此选项设置为 `10.7.0.1` 可实现与 SideStore/StosVPN 相同的行为，并且启用 `auto_redirect` 后可以作为网关为 LAN 设备实现相同的行为。",
    }),
    strict_route: z.boolean().optional().meta({
      description:
        "Enforce strict routing rules when `auto_route` is enabled. On Linux, unsupported networks become unreachable and ICMP traffic does not pass through TUN unless `strict_route` or `auto_redirect` is enabled. On Windows, it also prevents DNS leaks caused by ordinary multihomed DNS resolution behavior and may break applications like VirtualBox in some cases.",
      description_zh:
        "当启用 `auto_route` 时，强制执行严格的路由规则。在 Linux 上，不支持的网络将被置为不可达，除非启用 `strict_route` 或 `auto_redirect`，否则 ICMP 流量不会通过 TUN。在 Windows 上，它还可以防止普通多宿主 DNS 解析行为造成的 DNS 泄露，但在某些情况下可能会影响如 VirtualBox 的应用程序。",
    }),
    route_address: listableString.optional().meta({
      description:
        "Use custom routes instead of default when `auto_route` is enabled.",
      description_zh: "设置到 Tun 的自定义路由。",
    }),
    route_address_set: listableString.optional().meta({
      description:
        "Add the destination IP CIDR rules in the specified rule-sets to the firewall when `auto_redirect` is enabled, so unmatched traffic bypasses the sing-box routes. Without `auto_redirect`, the rules are added to routes (equivalent to `route_address`), but Android graphical clients may not support this due to VpnService limits. Conflict with `route.default_mark` and `[dialOptions].routing_mark` when `auto_redirect` is enabled.",
      description_zh:
        "在启用 `auto_redirect` 时，将指定规则集中的目标 IP CIDR 规则添加到防火墙。不匹配的流量将绕过 sing-box 路由。在未启用 `auto_redirect` 时，该规则相当于添加到 `route_address`。由于 Android VpnService 无法处理大量路由，Android 图形客户端可能无法使用此功能。启用 `auto_redirect` 时与 `route.default_mark` 和 `[dialOptions].routing_mark` 冲突。",
    }),
    route_exclude_address: listableString.optional().meta({
      description: "Exclude custom routes when `auto_route` is enabled.",
      description_zh: "设置到 Tun 的排除自定义路由。",
    }),
    route_exclude_address_set: listableString.optional().meta({
      description:
        "Add the destination IP CIDR rules in the specified rule-sets to the firewall when `auto_redirect` is enabled, so matched traffic bypasses the sing-box routes. Without `auto_redirect`, the rules are added to routes (equivalent to `route_exclude_address`), but Android graphical clients may not support this due to VpnService limits. Conflict with `route.default_mark` and `[dialOptions].routing_mark` when `auto_redirect` is enabled.",
      description_zh:
        "在启用 `auto_redirect` 时，将指定规则集中的目标 IP CIDR 规则添加到防火墙。匹配的流量将绕过 sing-box 路由。在未启用 `auto_redirect` 时，该规则相当于添加到 `route_exclude_address`。由于 Android VpnService 无法处理大量路由，Android 图形客户端可能无法使用此功能。启用 `auto_redirect` 时与 `route.default_mark` 和 `[dialOptions].routing_mark` 冲突。",
    }),
    include_interface: listableString.optional().meta({
      description:
        "Limit interfaces in route. Interface rules are only supported on Linux and require `auto_route`. Conflict with `exclude_interface`.",
      description_zh:
        "限制被路由的接口。接口规则仅在 Linux 下被支持，并且需要 `auto_route`。与 `exclude_interface` 冲突。",
    }),
    exclude_interface: listableString.optional().meta({
      description:
        "Exclude interfaces in route. When `strict_route` is enabled, return traffic to excluded interfaces will not be automatically excluded, so add them as well.",
      description_zh:
        "排除路由的接口。当启用 `strict_route` 时，返回到排除接口的流量不会被自动排除，因此也要添加它们。",
    }),
    include_uid: listableInts.optional().meta({
      description:
        "Limit users in route. UID rules are only supported on Linux and require `auto_route`.",
      description_zh:
        "限制被路由的用户。UID 规则仅在 Linux 下被支持，并且需要 `auto_route`。",
    }),
    include_uid_range: listableString.optional().meta({
      description:
        "Limit users in route, but in range. UID rules are only supported on Linux and require `auto_route`.",
      description_zh:
        "限制被路由的用户范围。UID 规则仅在 Linux 下被支持，并且需要 `auto_route`。",
    }),
    exclude_uid: listableInts.optional().meta({
      description:
        "Exclude users in route. UID rules are only supported on Linux and require `auto_route`.",
      description_zh:
        "排除路由的用户。UID 规则仅在 Linux 下被支持，并且需要 `auto_route`。",
    }),
    exclude_uid_range: listableString.optional().meta({
      description:
        "Exclude users in route, but in range. UID rules are only supported on Linux and require `auto_route`.",
      description_zh:
        "排除路由的用户范围。UID 规则仅在 Linux 下被支持，并且需要 `auto_route`。",
    }),
    include_android_user: listableInts.optional().meta({
      description:
        "Limit android users in route. Android user rules are only supported on Android and require `auto_route`.",
      description_zh:
        "限制被路由的 Android 用户。Android 用户规则仅在 Android 下被支持，并且需要 `auto_route`。",
    }),
    include_package: listableString.optional().meta({
      description:
        "Limit android packages in route. Android package rules are only supported on Android and require `auto_route`.",
      description_zh:
        "限制被路由的 Android 应用包名。Android 应用规则仅在 Android 下被支持，并且需要 `auto_route`。",
    }),
    exclude_package: listableString.optional().meta({
      description:
        "Exclude android packages in route. Android package rules are only supported on Android and require `auto_route`.",
      description_zh:
        "排除路由的 Android 应用包名。Android 应用规则仅在 Android 下被支持，并且需要 `auto_route`。",
    }),
    stack: z.enum(["system", "gvisor", "mixed"]).optional().meta({
      description:
        "TCP/IP stack. `system` performs L3 to L4 translation using the system network stack, `gvisor` uses gVisor's virtual network stack, and `mixed` pairs the system TCP stack with gVisor's UDP stack. Defaults to `mixed` if the gVisor build tag is enabled, otherwise defaults to `system`.",
      description_zh:
        "TCP/IP 栈。`system` 使用系统网络栈进行 L3 到 L4 的转换，`gvisor` 使用 gVisor 的虚拟网络栈，`mixed` 混合使用系统 TCP 栈和 gVisor UDP 栈。如果启用了 gVisor 构建标记，默认使用 `mixed`，否则默认使用 `system`。",
    }),
    platform: TunPlatformOptions.optional().meta({
      description:
        "Platform-specific settings, provided by client applications.",
      description_zh: "平台特定的设置，由客户端应用提供。",
    }),

    // Deprecated fields
    gso: z.boolean().optional().meta({
      description: "Enable generic segmentation offload.",
      description_zh: "启用通用分段卸载。",
      deprecated: true,
    }),
    inet4_address: listableString.optional().meta({
      description: "IPv4 prefix for the tun interface.",
      description_zh: "tun 接口的 IPv4 前缀。",
      deprecated: true,
    }),
    inet6_address: listableString.optional().meta({
      description: "IPv6 prefix for the tun interface.",
      description_zh: "tun 接口的 IPv6 前缀。",
      deprecated: true,
    }),
    inet4_route_address: listableString.optional().meta({
      description:
        "Use custom routes instead of default when `auto_route` is enabled.",
      description_zh: "启用 `auto_route` 时使用自定义路由而不是默认路由。",
      deprecated: true,
    }),
    inet6_route_address: listableString.optional().meta({
      description:
        "Use custom routes instead of default when `auto_route` is enabled.",
      description_zh: "启用 `auto_route` 时使用自定义路由而不是默认路由。",
      deprecated: true,
    }),
    inet4_route_exclude_address: listableString.optional().meta({
      description: "Exclude custom routes when `auto_route` is enabled.",
      description_zh: "启用 `auto_route` 时排除自定义路由。",
      deprecated: true,
    }),
    inet6_route_exclude_address: listableString.optional().meta({
      description: "Exclude custom routes when `auto_route` is enabled.",
      description_zh: "启用 `auto_route` 时排除自定义路由。",
      deprecated: true,
    }),
    endpoint_independent_nat: z.boolean().optional().meta({
      description:
        "Enable endpoint-independent NAT. This item is only available on the gvisor stack; other stacks are endpoint-independent NAT by default. Performance may degrade slightly, so it is not recommended to enable when it is not needed.",
      description_zh:
        "启用独立于端点的 NAT。此项仅在 gvisor 栈上可用，其他栈默认启用独立于端点的 NAT。性能可能略有下降，因此不建议在不需要时启用。",
    }),

    ...ListenOptions.shape,
  })
  .meta({
    id: "TunInboundOptions",
    title: "Tun Inbound",
    title_zh: "Tun 入站",
  });

export type TunInboundOptions = z.infer<typeof TunInboundOptions>;
